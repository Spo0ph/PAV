# File: sp500_agent.py
#!/usr/bin/env python3
"""
SP500 Agent für Trading basierend auf der SP500-Pipeline.

Dieses Skript liest das zuletzt generierte Signal aus 'sp500_signals.csv',
verbindet sich mit der IBKR Client Portal Web API (Papertrading) und führt
einen Marktorder für UPRO aus (BUY oder SELL) basierend auf dem Signal.

Benötigte Umgebungsvariablen:
- IBKR_USER: Benutzername für IBKR (z.B. 'conradfritsche')
- IBKR_PASS: Passwort für IBKR (z.B. 'hofdyx-vemtis-1rYsmo')
- API_HOST: Hostname des Client Portal Web API (Standard: 'localhost')
- API_PORT: Port des Client Portal Web API (Standard: '4001')
- UPRO_CONID: ConID für den UPRO-ETF

"""
import os
import sys
import requests
import pandas as pd

# Konfiguration aus Umgebungsvariablen
API_HOST   = os.getenv("API_HOST", "localhost")
API_PORT   = os.getenv("API_PORT", "4001")
IBKR_USER  = os.getenv("IBKR_USER")
IBKR_PASS  = os.getenv("IBKR_PASS")
UPRO_CONID = os.getenv("UPRO_CONID")

if not all([IBKR_USER, IBKR_PASS, UPRO_CONID]):
    print("Fehler: Umgebungsvariablen IBKR_USER, IBKR_PASS und UPRO_CONID müssen gesetzt sein.")
    sys.exit(1)

API_URL = f"http://{API_HOST}:{API_PORT}/v1/api"
CSV_FILE = "sp500_signals.csv"
HEADERS = {"Content-Type": "application/json"}


def load_latest_signal(filepath: str) -> str:
    """
    Liest das letzte Signal aus der CSV-Datei ein.
    """
    try:
        df = pd.read_csv(filepath)
    except Exception as e:
        print(f"Fehler beim Lesen der Datei {filepath}: {e}")
        sys.exit(1)
    if "SMA_DD_Signal" not in df.columns:
        print("Fehler: Spalte 'SMA_DD_Signal' nicht gefunden.")
        sys.exit(1)
    signal = df.iloc[-1]["SMA_DD_Signal"]
    print(f"Aktuelles Signal: {signal}")
    return str(signal).upper()


def authenticate() -> requests.Session:
    """
    Meldet sich bei der IBKR Client Portal Web API an und gibt eine Session zurück.
    """
    session = requests.Session()
    login_endpoint = f"{API_URL}/sso/login"
    payload = {"user": IBKR_USER, "password": IBKR_PASS}
    resp = session.post(login_endpoint, json=payload, headers=HEADERS)
    if resp.status_code != 200:
        print(f"Login fehlgeschlagen ({resp.status_code}): {resp.text}")
        sys.exit(1)
    return session


def get_account_summary(session: requests.Session):
    """
    Holt Kontodaten: Cash-Balance und UPRO-Position.
    Rückgabe: (account_id, cash_balance, upro_shares)
    """
    resp = session.get(f"{API_URL}/portfolio/accounts", headers=HEADERS)
    resp.raise_for_status()
    account_id = resp.json()[0]["accountId"]

    bal = session.get(f"{API_URL}/portfolio/{account_id}/net-liquidation", headers=HEADERS)
    bal.raise_for_status()
    cash_bal = float(bal.json().get("cashBal", 0.0))

    pos = session.get(f"{API_URL}/portfolio/{account_id}/positions", headers=HEADERS)
    pos.raise_for_status()
    shares = 0.0
    for p in pos.json():
        if str(p.get("conid")) == UPRO_CONID:
            shares = float(p.get("position", 0.0))
            break

    print(f"Konto: {account_id}, Cash: {cash_bal}, UPRO-Anteile: {shares}")
    return account_id, cash_bal, shares


def get_last_price(session: requests.Session) -> float:
    """
    Holt den letzten Kurs des UPRO-ETF.
    """
    r = session.get(f"{API_URL}/iserver/marketdata/snapshot?conids={UPRO_CONID}", headers=HEADERS)
    r.raise_for_status()
    price = float(r.json().get(UPRO_CONID, {}).get("last", 0.0))
    print(f"Aktueller UPRO-Kurs: {price}")
    return price


def place_order(session: requests.Session, account_id: str, side: str, qty: float):
    """
    Platziert eine Market-Order (BUY oder SELL) für UPRO.
    """
    order = {
        "acctId": account_id,
        "conid": int(UPRO_CONID),
        "secType": "ETF",
        "orderType": "MKT",
        "side": side,
        "quantity": qty
    }
    r = session.post(f"{API_URL}/trade/orders", json=order, headers=HEADERS)
    r.raise_for_status()
    print(f"Order ausgeführt: {side} {qty} UPRO")


def main():
    signal = load_latest_signal(CSV_FILE)
    session = authenticate()
    account_id, cash, shares = get_account_summary(session)

    if signal == "BUY" and cash > 0:
        price = get_last_price(session)
        qty = int(cash // price)
        if qty > 0:
            place_order(session, account_id, "BUY", qty)
        else:
            print("Nicht genug Cash für UPRO-Anteile.")
    elif signal == "SELL" and shares > 0:
        place_order(session, account_id, "SELL", shares)
    else:
        print("Keine Aktion erforderlich.")

if __name__ == "__main__":
    main()